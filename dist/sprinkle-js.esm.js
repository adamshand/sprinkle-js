const getDomElement=a=>"string"==typeof a?document.querySelector(a):a,updateDom=(a,b,c=[])=>{const d=Object.entries(b);for(let[e,f]of d){if("object"==typeof f)return void updateDom(a,f,[...c,e]);let b=a;for(const a of c)b=b[a];"style"===c[c.length-1]&&b.setProperty(e,f),b[e]=f;}},createMatrix=(a,b)=>[...Array(a).keys()].map(()=>Array(b).fill(0)),diff=(a=[],b=[],c=(c,a)=>c===a)=>{var d=Math.min;const e=createMatrix(a.length+1,b.length+1);for(let d=0;d<a.length+1;d++)e[d][0]=d;for(let d=0;d<b.length+1;d++)e[0][d]=d;for(let f=0;f<a.length;f++)for(let g=0;g<b.length;g++)if(c(a[f],b[g]))e[f+1][g+1]=e[f][g];else {const a=d(e[f+1][g],e[f][g+1])+1;e[f+1][g+1]=a;}const f=[];let g=a.length,h=b.length;for(;0<g&&0<h;)c(a[g-1],b[h-1])?(f.unshift({type:"=",value:a[g-1]}),h--,g--):e[g-1][h]<e[g][h-1]?(f.unshift({type:"-",value:a[g-1]}),g--):(f.unshift({type:"+",value:b[h-1]}),h--);return 0<g?f.unshift(...(a?.slice?.(0,g)?.map?.(a=>({type:"-",value:a}))||[])):0<h&&f.unshift(...(b?.slice?.(0,h)?.map?.(a=>({type:"+",value:a}))||[])),f},findNext=(a,b,c=0)=>a.find((a,d,...e)=>d>c&&b(a,d,...e)),getRawType=a=>Object.prototype.toString.call(a).slice(8,-1);

let context=[];const subscribe=(a,b,c)=>{let d=c.get(a);d||(d=new Set,c.set(a,d)),d.add(b),b.dependencies.add(d);},runRupdates=(a,b)=>{for(const c of [...(a.get(b)||[])]){const a=c.execute();a&&(c.cleanup=a);}},createVariable=(a,b)=>{if("object"!=typeof a)throw new Error("It's not possible to create a variable from a primitive value...you can use createRef");const c=Object.keys(a);for(let d of c){const c=d;!!a[c]&&"object"==typeof a[c]&&("Object"===getRawType(a[c])||Array.isArray(a[c]))&&(a[c]=createVariable(a[c],b?.[c]));}const d=new Map,e=new Proxy(a,{get:(...a)=>{const b=context[context.length-1];return b&&subscribe(a[1],b,d),Reflect.get(...a)},set:(a,c,e)=>{const f=c,g=b?.[f]??Object.is;let h=e;!!e&&"object"==typeof e&&("Object"===getRawType(e)||Array.isArray(e))&&(h=createVariable(e,g));const i=g(a[f],e),j=Reflect.set(a,c,h);return i||runRupdates(d,c),j}});return e},createComputed=(a,b)=>{const c={value:a()};let d=!1;const e=new Map,f=new Proxy(c,{get:(...a)=>{const b=context[context.length-1];return b&&subscribe(a[1],b,e),Reflect.get(...a)},set:(a,c,f)=>{if(!d)return !0;const g=b??Object.is,h=g(a[c],f),i=Reflect.set(a,c,f);return h||runRupdates(e,c),i}});return createEffect(()=>{d=!0,f.value=a(),d=!1;}),f},createStored=(a,b,c,d=window.localStorage)=>{if("object"!=typeof b)throw new Error("It's not possible to create a variable from a primitive value...you can use createRef");const e=new Map;let f=null;try{const c=d.getItem(a);c?f=JSON.parse(c):d.setItem(a,JSON.stringify(b));}catch(a){throw new Error("The specified key is associated with a non Object-like element")}const g=new Proxy(f??b,{get:(...a)=>{const b=context[context.length-1];return b&&subscribe(a[1],b,e),Reflect.get(...a)},set:(b,f,g)=>{const h=f,i=c?.[h]??Object.is,j=i(b[h],g),k=Reflect.set(b,f,g);return d.setItem(a,JSON.stringify(b)),j||runRupdates(e,f),k}});return window.addEventListener("storage",b=>{if(b.storageArea===d&&b.key===a)try{if(b.newValue){const a=JSON.parse(b.newValue);for(let b in a)g[b]=a[b];}}catch(a){console.warn("The storage was modified but the resulting object is not parsable...the variable was not updated.");}}),g},createRef=(a,b)=>createVariable({value:a},b?{value:b}:void 0),cleanup=a=>{for(const b of a.dependencies)b.delete(a);a.dependencies.clear();},createEffect=a=>{const b=()=>{c.cleanup&&c.cleanup(),cleanup(c),context.push(c);let b;try{b=a();}finally{context.pop();}return b},c={execute:b,dependencies:new Set},d=b();d&&(c.cleanup=d);},untrack=a=>{const b=context;context=[];const c=a();return context=b,c},bindTextContent=(a,b)=>{const c=getDomElement(a);return createEffect(()=>{c&&(c.textContent=b(c));}),c},bindInnerHTML=(a,b)=>{const c=getDomElement(a);return createEffect(()=>{c&&(c.innerHTML=b(c));}),c},bindClass=(a,b,c)=>{const d=getDomElement(a);return createEffect(()=>{if(d){const a=c(d);a?d.classList.add(b):d.classList.remove(b);}}),d},bindInputValue=(a,b)=>{const c=getDomElement(a);return createEffect(()=>{c&&(c.value=b(c));}),c},bindDom=(a,b)=>{const c=getDomElement(a);return createEffect(()=>updateDom(c,b(c))),c},bindStyle=(a,b)=>{const c=getDomElement(a);if(c)return bindDom(c,()=>({style:b(c)})),c},bindChildrens=(a,b)=>{const c=getDomElement(a);return createEffect(()=>{if(null===c)return;const a=b(c);if(0===c.childNodes.length)return void c.append(...Array.from(a));const d=diff([...Array.from(c.childNodes)],[...Array.from(a)],(c,a)=>null!=c.key&&null!=a.key?c.key===a.key:c===a);let e=d.find(a=>"="===a.type),f=0;for(let a of d){if("+"===a.type){const b=findNext(d,b=>"-"===b.type&&b.value.key===a.value.key,f);if(b&&(a.value=b.value),!e){c.append(a.value),f++;continue}e.value.before(a.value);}else if("-"===a.type){c.removeChild(a.value);const b=findNext(d,b=>"+"===b.type&&b.value.key===a.value.key,f);b&&(b.value=a.value);}else e=findNext(d,a=>"="===a.type,f);f++;}}),c};

export { bindChildrens, bindClass, bindDom, bindInnerHTML, bindInputValue, bindStyle, bindTextContent, createComputed, createEffect, createRef, createStored, createVariable, untrack };
